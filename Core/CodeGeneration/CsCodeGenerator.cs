// CsCodeGenerator.cs - Generates C# code files from transformed models
using System;
using System.IO;
using System.Linq;
using System.Text;
using Transpiler.Core.Transformation;

namespace Transpiler.Core.CodeGeneration
{
    public class CsCodeGenerator
    {
        public void GenerateCode(CsClassModel csClass, string outputDirectory)
        {
            if (!Directory.Exists(outputDirectory))
            {
                Directory.CreateDirectory(outputDirectory);
            }
            
            string fileName = $"{csClass.Name}.cs";
            string filePath = Path.Combine(outputDirectory, fileName);
            
            StringBuilder code = new StringBuilder();
            
            // Add header comment
            code.AppendLine("// Generated C# code from C++ class");
            code.AppendLine($"// Source: {csClass.SourceFileName}");
            code.AppendLine("// Generated by C++ to C# Transpiler");
            code.AppendLine();
            
            // Add pragma to suppress unused field warnings
            code.AppendLine("#pragma warning disable CS0169 // Field is never used");
            
            // Add using statements
            code.AppendLine("using System;");
            code.AppendLine("using System.Collections.Generic;");
            code.AppendLine();
            
            // Begin class declaration
            code.Append("public ");
            
            // Add abstract modifier if needed
            if (csClass.IsAbstract)
            {
                code.Append("abstract ");
            }
            
            code.Append("class ").Append(csClass.Name);
            
            // Add base classes if any
            if (csClass.BaseClasses.Count > 0)
            {
                code.Append(" : ").Append(string.Join(", ", csClass.BaseClasses));
            }
            
            code.AppendLine();
            code.AppendLine("{");
            
            // Generate fields
            foreach (var field in csClass.Fields)
            {
                code.Append("    ").Append(field.Visibility).Append(" ");
                code.Append(field.Type).Append(" ");
                code.Append(field.Name).AppendLine(";");
            }
            
            if (csClass.Fields.Count > 0)
            {
                code.AppendLine();
            }
            
            // Generate properties
            foreach (var property in csClass.Properties)
            {
                code.Append("    ").Append(property.Visibility).Append(" ");
                code.Append(property.Type).Append(" ");
                code.Append(property.Name).Append(" { ");
                
                if (property.HasGetter)
                {
                    code.Append("get; ");
                }
                
                if (property.HasSetter)
                {
                    code.Append("set; ");
                }
                
                code.AppendLine("}");
            }
            
            if (csClass.Properties.Count > 0)
            {
                code.AppendLine();
            }
            
            // Generate constructors and methods
            foreach (var method in csClass.Methods)
            {
                // Add any comments
                if (!string.IsNullOrEmpty(method.Comment))
                {
                    code.Append("    ").AppendLine(method.Comment);
                }
                
                // Handle special case for destructors
                if (method.IsDestructor)
                {
                    code.Append("    ~").Append(method.Name);
                    
                    // Add parameters
                    code.Append("(");
                    if (method.Parameters.Count > 0)
                    {
                        var paramStrings = method.Parameters
                            .Select(p => $"{p.Type} {p.Name}")
                            .ToArray();
                        
                        code.Append(string.Join(", ", paramStrings));
                    }
                    code.AppendLine(")");
                    
                    // Method body
                    code.AppendLine("    {");
                    code.AppendLine("        // TODO: implement cleanup");
                    code.AppendLine("    }");
                    code.AppendLine();
                    
                    continue; // Skip the regular method rendering
                }
                
                code.Append("    ").Append(method.Visibility).Append(" ");
                
                if (method.IsOverride)
                {
                    code.Append("override ");
                }
                else if (method.IsAbstract)
                {
                    code.Append("abstract ");
                }
                
                // Constructors don't have return type
                if (!method.IsConstructor)
                {
                    code.Append(method.ReturnType).Append(" ");
                }
                
                code.Append(method.Name);
                
                // Add parameters
                code.Append("(");
                if (method.Parameters.Count > 0)
                {
                    var paramStrings = method.Parameters
                        .Select(p => $"{p.Type} {p.Name}")
                        .ToArray();
                    
                    code.Append(string.Join(", ", paramStrings));
                }
                // For abstract methods, just add a semicolon instead of a method body
                if (method.IsAbstract)
                {
                    code.AppendLine(");");
                    code.AppendLine();
                    continue;
                }
                code.AppendLine(")");
                
                // Method body for non-abstract methods
                code.AppendLine("    {");
                
                if (method.IsConstructor)
                {
                    code.AppendLine("        // TODO: implement constructor");
                }
                else if (method.IsEquals)
                {
                    code.AppendLine("        // TODO: implement equality comparison");
                    code.AppendLine("        return false; // Default implementation");
                }
                else
                {
                    if (method.ReturnType != "void" && method.ReturnType != "")
                    {
                        code.AppendLine("        // TODO: implement method");
                        code.Append("        return ");
                        
                        // Generate a default return value
                        switch (method.ReturnType)
                        {
                            case "int":
                            case "byte":
                            case "short":
                            case "long":
                                code.AppendLine("0;");
                                break;
                            case "float":
                            case "double":
                            case "decimal":
                                code.AppendLine("0.0;");
                                break;
                            case "bool":
                                code.AppendLine("false;");
                                break;
                            case "string":
                                code.AppendLine("\"\";");
                                break;
                            default:
                                code.AppendLine("null;");
                                break;
                        }
                    }
                    else
                    {
                        code.AppendLine("        // TODO: implement method");
                    }
                }
                
                code.AppendLine("    }");
                code.AppendLine();
            }
            
            // Close class
            code.AppendLine("}");
            
            // Write to file
            File.WriteAllText(filePath, code.ToString());
            
            Console.WriteLine($"Generated: {filePath}");
        }
    }
} 
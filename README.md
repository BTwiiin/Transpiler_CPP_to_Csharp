# C++ to C# Class Transpiler

A custom transpiler that converts C++ class declarations to C# class definitions.

## Overview

This transpiler reads C++ header/source files and generates equivalent C# class files. It follows a character-by-character parsing approach without using regex or advanced parsing libraries.

## Features

- Parses basic C++ class structures from header and source files (e.g., .h, .hpp, .cpp)
- Identifies classes, inheritance relationships, fields, constructors, destructors, and methods (including operators)
- Converts recognized C++ constructs into the closest C# equivalents
- Preserves member visibility (private → private, public → public, etc.)
- Generates one .cs file per class
- Converts getter/setter methods into C# properties
- Transforms operator== to an override of Equals(object other)

## Architecture

The transpiler follows a modular design with the following components:

1. **Input Reader** - Reads characters one-by-one from each file
2. **Scanner** - Converts characters into tokens (identifiers, keywords, symbols)
3. **Parser** - Uses the grammar to build an internal representation of classes, fields, and methods
4. **Transformation Module** - Maps parsed C++ constructs to data structures describing C# equivalents
5. **Code Generator** - Writes final .cs files

## Project Structure

```
Transpiler/
├── Core/                           # Core implementation
│   ├── Lexing/                    # Character and token processing
│   │   ├── InputReader.cs         # File input handling
│   │   └── Scanner.cs             # Token creation
│   ├── Parsing/                   # Grammar and syntax analysis
│   ├── Models/                    # Data structures
│   ├── Transformation/            # C++ to C# conversion logic
│   ├── CodeGeneration/            # C# code generation
│   └── CppToCsTranspiler.cs       # Main transpiler class
├── TestFiles/                     # Sample C++ input files
├── Output/                        # Generated C# files
├── Program.cs                     # Application entry point
├── TestTranspiler.ps1            # Test script
└── Transpiler.csproj             # Project configuration
```

## Application Flow

1. **Input Processing**
   - The application accepts C++ header/source files as command-line arguments
   - Each input file is validated for existence before processing

2. **Transpilation Process**
   - For each input file:
     1. **Lexical Analysis**: `InputReader` reads the file character by character
     2. **Tokenization**: `Scanner` converts characters into meaningful tokens
     3. **Parsing**: The parser builds an abstract syntax tree (AST) from tokens
     4. **Transformation**: C++ constructs are mapped to C# equivalents
     5. **Code Generation**: C# code is generated and written to output files

3. **Output Generation**
   - Generated C# files are placed in the `Output` directory
   - One .cs file is created per C++ class
   - Output files include source file references and generation timestamps

## Usage

```
dotnet run -- <input_file1.cpp> <input_file2.h> ...
```

The transpiler will generate .cs files in the Output directory.

## Test Script

The project includes a PowerShell test script (`TestTranspiler.ps1`) that demonstrates the transpiler functionality with sample C++ input files.

```
.\TestTranspiler.ps1
```

## Sample Input/Output

### Input (Simple.h)
```cpp
class Simple
{
private:
    int number;
public:
    Simple();
    int get_number();
    void set_number(int val);
};
```

### Output (Simple.cs)
```csharp
// Generated C# code from C++ class
// Source: Simple.h
// Generated by C++ to C# Transpiler

using System;
using System.Collections.Generic;

public class Simple
{
    public int Number { get; set; }
}
```

## Limitations

- The parser doesn't handle complex C++ features like templates or macros
- Method bodies in C# contain only TODO comments for further implementation
- Some C++ constructs like destructors may need manual refinement in the generated C# code

## Project Status

This project is a demonstration of a character-by-character parsing solution for C++ class declarations. It can be extended to handle more complex C++ constructs and improve error handling. 


## 